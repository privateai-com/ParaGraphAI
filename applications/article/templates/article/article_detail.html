{% extends "base.html" %}
{% load article_extras %}
{% load static %}


{% block title %}{{ article.title|truncatechars:60 }}{% endblock %}

{% block extra_head %}
<style>

    .article-page{
        display: flex;
        gap: 20px;
        flex: 1;
    }

    .article-page h2{
        margin-top: 0px;
    }

    .article-page-column{
        display: flex;
        flex-direction: column;
        max-height: 100%;
        position: relative;
        overflow: hidden;
    }

    .article-other-info .tab-container{
        position: absolute;
    }

     .article-page-column:first-child{
        flex: 0.35;
     }

     .article-page-column:last-child{
        flex: 0.65;
     }

    .detail-section {
        padding-bottom: 15px;
        /* border-bottom: 1px solid #eee; */
    }
    .detail-section h3 {
        margin-top: 0;
        color: #555;
    }
    .metadata-grid {
        display: grid;
        grid-template-columns: 150px 1fr;
        gap: 5px 15px;
    }
    .metadata-grid dt {
        font-weight: bold;
        color: #333;
    }
    .metadata-grid dd {
        margin-left: 0;
    }

    .content-list,.reference-list{
        margin: 0;
    }

    .content-list li, .reference-list li {
        background-color:var(--light-button-bg-color);
        border: 1px solid var(--border-color);
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 3px;
        border-left: 3px solid var(--primary-color);
    }
    .reference-list li .status {
        font-size: 0.85em;
        color: #666;
        display: block;
        margin-top: 5px;
    }
  
    .raw-content-toggle {
        cursor: pointer;
        color: var(--primary-color);
        text-decoration: underline;
        font-size: 0.9em;
    }
    .raw-content-data {
        display: none;
        white-space: pre-wrap;
        background-color: #272822;
        color: #f8f8f2;
        padding: 10px;
        border-radius: 4px;
        margin-top: 5px;
        max-height: 300px;
        overflow-y: auto;
        font-family: monospace;
    }


 

    /* ... стили для редактирования частей статьи ... */
    .section-editor {
        display: flex;
        flex-direction: column;
        justify-content: center;
        margin-bottom: 15px;
        border-radius: var(--border-radius);
        padding: 10px;
        border: 1px solid var(--border-color);
        background-color: var(--light-button-bg-color);
    }

    #display-title:empty{
        display: none;
    }

    .section-editor h4 button{
        margin-left: 10px;
    }

    .section-editor h4{
        margin-bottom: 10px;
        margin-top: 20px;
    }

    .section-editor:last-child{
    margin-bottom: 0px;
    }

    .section-editor textarea {
        width: calc(100% - 22px);
        min-height: 150px;
        padding: 10px;
        margin-bottom: 10px;
        border: 1px solid #ccc;
    }
    .section-display {
        padding: 5px 0;
    }
    .edit-section-btn {
        font-size: 0.8em;
        padding: 4px 8px;
        cursor: pointer;
    }

    .section-editor{

    }

    /* .save-section-btn {
        background-color: #5cb85c;
        color: white;
    } */
    /* .cancel-section-btn {
        background-color: #aaa;
        color: white;
    } */

    .add-section-btn {
        /* display: block;
        padding: 10px 15px;
        background-color: var(--primary-color);  */
        /* Info color */
        /* color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        text-align: center; */
    }

    .actions{
        display: flex;
        gap: 10px;
        
        flex-wrap: wrap;
    }

    .reference-list .actions{
        margin-top: 10px;
    }

    .reference-list .actions button, .section-editor .actions button{
        font-size: 0.8em;
        padding: 3px 6px;
    }

    .section-editor h5{
        margin: 0;
        font-size: inherit;
    }

    /* .add-section-btn:hover { background-color: var(--primary-color); } */

    /* стили для анализируемых участков текста */
  
    .segment-section-group {
        padding-top: 10px;
    }

    .segment-section-group:last-child{
        margin-bottom: 0px;
    }

    .segment-section-group-head{
        display: flex;
        background-color: var(--bg-color-pair-n);
        color: inherit;
        padding: 8px 12px;
        gap: 10px;
        border-radius: 4px;
        width: 100%;
        text-align: center;
        border: 0;
        /* padding-left: calc(12px + 10px + 16px); */
    }

    .segment-section-group-head h4 {
        flex: 1;
        margin: 0;
        /* border-bottom: 2px solid #e0e2e5; */
    }

    .segment-section-group-head svg{
        height: 18.666px;
        display: flex;
        rotate: 180deg;
    }

    .analyzed-segment-item {
        border: 1px solid #d1e7fd;
        background-color: #f8f9fa;
        padding: 15px;
        margin-bottom: 15px;
        border-radius: 4px;
        /* position: relative; Для позиционирования кнопок */
    }

    .analyzed-segment-item .actions button{
        font-size: 0.8em;
        padding: 3px 6px;
    }

    .analyzed-segment-item p {
        margin-top: 0;
        line-height: 1.6;
    }
    .segment-references-list {
        list-style-type: none;
        padding-left: 15px;
        margin-top: 10px;
        font-size: 0.9em;
        border-top: 1px dashed #ccc;
        padding-top: 10px;
    }
    .segment-references-list li {
        margin-bottom: 5px;
    }

    .analyzed-segment-list{
        margin-top: 10px;
        display: none;
    }

    .show .analyzed-segment-list{
        display: block;
    }

    .show .segment-section-group-head svg{
        rotate: 0deg;
    }

 
</style>
{% endblock %}

{% block content %}
{# *** Блок уведомлений теперь ВНАЧАЛЕ .container *** #}
<div id="notifications-wrapper">
    <div id="notifications">
        {# Сообщения будут добавляться сюда JavaScript'ом #}
        <p style="text-align: center; color: #6c757d; margin: 5px 0;">Waiting for notifications...</p>
    </div>
    <botton id="notifications-toggle-button">
        <svg class="toggle-button-closed-svg" width="24" height="24" viewBox="0 0 26 26" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g filter="url(#filter0_d_8537_320451)">
                <path fill-rule="evenodd" clip-rule="evenodd" d="M6.00066 9C6.00066 7.14348 6.73816 5.36301 8.05092 4.05025C9.36367 2.7375 11.1441 2 13.0007 2C14.8572 2 16.6377 2.7375 17.9504 4.05025C19.2632 5.36301 20.0007 7.14348 20.0007 9V12.764L21.8227 16.408C21.9065 16.5757 21.9461 16.7621 21.9377 16.9494C21.9293 17.1368 21.8731 17.3188 21.7745 17.4783C21.6759 17.6379 21.5382 17.7695 21.3744 17.8608C21.2106 17.9521 21.0262 18 20.8387 18H16.8747C16.6522 18.8582 16.1511 19.6183 15.4499 20.1609C14.7488 20.7035 13.8873 20.9979 13.0007 20.9979C12.1141 20.9979 11.2526 20.7035 10.5514 20.1609C9.85023 19.6183 9.3491 18.8582 9.12666 18H5.16266C4.97514 18 4.79072 17.9521 4.62693 17.8608C4.46314 17.7695 4.3254 17.6379 4.22681 17.4783C4.12822 17.3188 4.07204 17.1368 4.06361 16.9494C4.05518 16.7621 4.09479 16.5757 4.17866 16.408L6.00066 12.764V9ZM11.2687 18C11.4442 18.304 11.6967 18.5565 12.0007 18.732C12.3047 18.9075 12.6496 18.9999 13.0007 18.9999C13.3517 18.9999 13.6966 18.9075 14.0006 18.732C14.3046 18.5565 14.5571 18.304 14.7327 18H11.2687ZM13.0007 4C11.6746 4 10.4028 4.52678 9.46513 5.46447C8.52745 6.40215 8.00066 7.67392 8.00066 9V12.764C8.00064 13.0743 7.9284 13.3804 7.78966 13.658L6.61966 16H19.3827L18.2127 13.658C18.0736 13.3805 18.001 13.0744 18.0007 12.764V9C18.0007 7.67392 17.4739 6.40215 16.5362 5.46447C15.5985 4.52678 14.3267 4 13.0007 4Z" fill="black"/>
            </g>
          
        </svg>
        <svg class="toggle-button-opened-svg" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"/>
        </svg>
    </botton>
    
</div>
<div class="container">
    <div class="article-page">
        <div class="article-current-info article-page-column" style="position: relative;">
            <div class="scrollable-content" style="position: absolute; left: 0;top: 0;
            border:none; padding: 0;">
                {# *** НАЧАЛО: Добавление фиктивной формы с CSRF-токеном *** #}
                <form style="display:none;">
                    {% csrf_token %}
                </form>
                {# *** КОНЕЦ: Добавление фиктивной формы с CSRF-токеном *** #}

                {{ references_for_js|json_script:"article-references-data-script" }}

                <h2>{{ article.title|default:"(Заголовок не определен)" }}</h2>

                <div class="detail-section metadata">
                    <h3>Basic information</h3>
                    <dl class="metadata-grid">
                        <dt>Authors:</dt>
                        <dd>
                            {% for author in article.authors.all %}
                                {{ author.full_name }}{% if not forloop.last %}; {% endif %}
                            {% empty %}
                                Not specified
                            {% endfor %}

                            {% comment %} {% for author in article.articleauthor_set.all %}
                                {{ author.author.full_name }}{% if not forloop.last %}; {% endif %}
                            {% empty %}
                                Not specified
                            {% endfor %} {% endcomment %}
                        </dd>
                        <dt>DOI:</dt><dd>{{ article.doi|default:"-" }}</dd>
                        <dt>PMID:</dt><dd>{{ article.pubmed_id|default:"-" }}</dd>
                        <dt>arXiv ID:</dt><dd>{{ article.arxiv_id|default:"-" }}</dd>
                        <dt>Publication date:</dt><dd>{{ article.publication_date|date:"d.m.Y"|default:"-" }}</dd>
                        <dt>Journal/Source:</dt><dd>{{ article.journal_name|default:"-" }}</dd>
                        <dt>Source of basic data:</dt><dd>{{ article.primary_source_api|upper|default:"-" }}</dd>
                        <dt>PDF OA URL:</dt><dd><a href="{{ article.best_oa_pdf_url }}" target="_blank" rel="noopener noreferrer">{{ article.best_oa_pdf_url }}</a></dd>
                        <dt>PDF file:</dt><dd>{% if article.pdf_file %}<a href="{{ article.pdf_file.url }}" target="_blank">PDF file of the article</a>{% endif %}</dd>
                    </dl>
                </div>

                <div class="actions" style="margin-bottom:20px;">
                    <button onclick="deleteArticle('{{ article.id }}', this)" class="cancel-button">Delete article</button>
                </div>
            </div>
        </div>

        <div class="article-other-info article-page-column">

            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button" data-tab="available-content-and-raw-data">Available content and raw data</button>
                    <button class="tab-button" data-tab="automatically-linked-text-segments">Automatically linked text segments</button>
                    <button class="tab-button" data-tab="content-of-the-article-by-section">Article content by section (editable)</button>
                    <button class="tab-button" data-tab="other-sections">Other sections</button>
                    <button class="tab-button" data-tab="structured-content-of-the-article">Structured content of the article</button>
                    <button class="tab-button" data-tab="clear-text-for-llm">Clear text (for LLM)</button>
                    <button class="tab-button" data-tab="list-of-references">List of references ({{ references_made|length }})</button>
                </div>

                <div class="tab-content" id="available-content-and-raw-data">
                    {% if contents %}
                            <h3>Available content and raw data</h3>
                            <div class="scrollable-content">
                                <ul class="content-list" style="padding-left:0; list-style:none;">
                                    {% for content_item in contents %}
                                    <li>
                                        <strong>{{ content_item.source_api_name|upper }}</strong> - {{ content_item.format_type }}
                                        <small>(Retrieved: {{ content_item.retrieved_at|date:"d.m.Y H:i" }})</small>


                                        {% if content_item.format_type == "link_openaccess_pdf" %}
                                            <br><a href="{{ content_item.content }}" target="_blank" rel="noopener noreferrer">Ссылка на PDF</a>
                                        {% else %}
                                            <br><span class="raw-content-toggle" onclick="toggleRawContent(this, 'content-{{ content_item.id }}')">Show</span>
                                            <div id="content-{{ content_item.id }}" class="raw-content-data">{% autoescape off %}{{ content_item.content }}{% endautoescape %}</div>
                                        {% endif %}
                                    </li>
                                    {% endfor %}

                                    {% if article.pdf_text %}
                                        <li>
                                            <strong>PDF</strong> - text
                                            <small>(Retrieved: {{ article.created_at|date:"d.m.Y H:i" }})</small>
                                            <br><span class="raw-content-toggle" onclick="toggleRawContent(this, 'pdf-file-text-{{ article.id }}')">Show</span>
                                            <div id="pdf-file-text-{{ article.id }}" class="raw-content-data">{% autoescape off %}{{ article.pdf_text }}{% endautoescape %}</div>
                                        </li>
                                    {% endif %}
                                </ul>
                            </div>
                    {% endif %}
                </div>
                <div class="tab-content" id="automatically-linked-text-segments">
                    
                    
                    <h3>Automatically linked text segments</h3>

                    
                    <div class="scrollable-content">
                        {# === НОВЫЙ БЛОК ДЛЯ ОТОБРАЖЕНИЯ СЕГМЕНТОВ === #}
                        <div class="">
                            <h4 style="margin: 0;">
                                Navigation by sections:
                            </h4>
                            <nav style="margin: 10px 0 10px; display: flex; flex-direction: row; gap:5px; flex-wrap: wrap;">
                                    {% if analyzed_segments %}
                                        {# Группируем сегменты по названию секции #}
                                        {% regroup analyzed_segments by section_key as segments_by_section %}

                                        {% for section in segments_by_section %}
                                            <a class="stroked-button" style="flex:auto;text-align: center; color:var(--primary-color); font-size: 13px; padding: 3px 5px;" href='#{{ section.grouper|default:"(Without section)" }}'>{{ section.grouper|default:"(Without section)" }}</a>
                                        {% endfor %}
                                    {% endif %}
                            </nav>
                            <div style=" border-top: 1px solid;border-color: var(--border-color); margin: 10px 0 0"  ></div>
                        </div>
                        <div class="detail-section analyzed-segments-wrapper">
                            
                            {% if analyzed_segments %}
                                {# Группируем сегменты по названию секции #}
                                {% regroup analyzed_segments by section_key as segments_by_section %}

                                {% for section in segments_by_section %}
                                    <div class="segment-section-group show" id='{{ section.grouper|default:"(Without section)" }}'>
                                        <button class="segment-section-group-head" onclick="handleSegmentToggle({tab: `{{section.grouper}}`, parentClass: '.segment-section-group', listClass:'.analyzed-segment-list', root:'.analyzed-segments-wrapper'})">
                                            <h4>Section: {{ section.grouper|default:"(Without section)" }}</h4>
                                            <!-- <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <path d="M2.93154 10.8426L7.61654 6.23165C7.71876 6.13052 7.85675 6.07379 8.00054 6.07379C8.14433 6.07379 8.28232 6.13052 8.38454 6.23165L13.0695 10.8416C13.1724 10.9427 13.3108 10.9994 13.455 10.9994C13.5992 10.9994 13.7377 10.9427 13.8405 10.8416C13.8912 10.7923 13.9314 10.7333 13.9589 10.6681C13.9864 10.6029 14.0006 10.5329 14.0006 10.4621C14.0006 10.3914 13.9864 10.3214 13.9589 10.2562C13.9314 10.191 13.8912 10.132 13.8405 10.0826L9.15654 5.47265C8.84802 5.16972 8.43292 5 8.00054 5C7.56816 5 7.15306 5.16972 6.84454 5.47265L2.16054 10.0826C2.10974 10.132 2.06936 10.1911 2.04178 10.2564C2.01421 10.3217 2 10.3918 2 10.4626C2 10.5335 2.01421 10.6036 2.04178 10.6689C2.06936 10.7342 2.10974 10.7933 2.16054 10.8426C2.2634 10.9437 2.40183 11.0004 2.54604 11.0004C2.69025 11.0004 2.82869 10.9437 2.93154 10.8426Z" fill="black"/>
                                            </svg> -->

                                        </button>
                                        <div class="analyzed-segment-list">
                                        {% for segment in section.list %}
                                            <div class="analyzed-segment-item" id="segment-{{ segment.pk }}">
                                                {# Текст сегмента (абзаца) #}
                                                <p>{{ segment.segment_text|linebreaksbr }}</p>

                                                {# Отображение связанных ссылок #}
                                                {% if segment.cited_references.all %}
                                                    <strong>Related sources:</strong>
                                                    <ul class="segment-references-list">
                                                    {% comment %} {% for ref_link in segment.cited_references.all %} {% endcomment %}
                                                    {% for ref_link in segment.cited_references.all|dictsort:"manual_data_json.jats_ref_id" %}
                                                        <li>
                                                            <span style="font-weight: bold; color: #0056b3;">
                                                                {% if ref_link.manual_data_json.jats_ref_id %}
                                                                    [{{ ref_link.manual_data_json.jats_ref_id }}]
                                                                {% endif %}
                                                            </span>
                                                            {% if ref_link.resolved_article %}
                                                                <a href="{% url 'article_detail' ref_link.resolved_article.pk %}" title="{{ ref_link.resolved_article.title }}" 
                                                                style={% if not ref_link.resolved_article.cleaned_text_for_llm and not ref_link.resolved_article.pdf_text %}color:#d9534f;{% else %}color:#0056b3;{% endif %}
                                                                >{{ ref_link.resolved_article.title|truncatechars:80 }}</a>
                                                            {% elif ref_link.manual_data_json.title %}
                                                                {{ ref_link.manual_data_json.title|truncatechars:80 }}
                                                            {% else %}
                                                                {{ ref_link.raw_reference_text|truncatechars:80 }}
                                                            {% endif %}
                                                            {% if ref_link.target_article_doi %}
                                                                <small> (DOI: {{ ref_link.target_article_doi }})</small>
                                                            {% endif %}
                                                        </li>
                                                    {% endfor %}
                                                    </ul>
                                                {% else %}
                                                    <p><small><i>No related links were found in this segment.</i></small></p>
                                                {% endif %}

                                                <div id="llm-analysis-results-{{ segment.pk }}" style="margin-top: 10px; padding: 8px; background-color: #f0f8ff; border-radius: 3px;">
                                                    <strong>LLM Analysis:</strong>
                                                    {% if segment.llm_analysis_notes %}
                                                        <p><i>Notes:</i> {{ segment.llm_analysis_notes|linebreaksbr }}</p>
                                                        <p><i>Veracity score (1–5):</i> {{ segment.llm_veracity_score|default:"not rated" }}</p>
                                                        <p><small>Model: {{ segment.llm_model_name|default:"not specified" }} ({{ segment.updated_at|date:"d.m.Y H:i" }})</small></p>
                                                    {% else %}
                                                        <p>Analyses have not yet been conducted or are in process.</p>
                                                    {% endif %}
                                                </div>


                                                <div class="actions" style="margin-top: 10px;">
                                                    <button class="llm-analyze-segment-btn" data-segment-id="{{ segment.pk }}">Analyse with the LLM</button>
                                                    <button disabled title="Действие пока не реализовано">Edit</button>
                                                    <button disabled title="Действие пока не реализовано" style="background-color:#d9534f; color:white;">Delete</button>
                                                </div>
                                            </div>
                                        {% endfor %}
                                        </div>
                                    </div>
                                {% endfor %}
                            {% else %}
                                <p>No analysable segments have yet been created for this article. If you have uploaded the full text in XML format, the task of creating them may still be in the queue.</p>
                            {% endif %}
                        </div>
                    </div>
                        {# === КНОПКА СОЗДАНИЯ СЕГМЕНТА (появляется при выделении текста) === #}
                    <button type="button" class="primary-button" id="createSegmentBtn">Create a segment from a selection</button>
                </div>
                <div class="tab-content" id="content-of-the-article-by-section">
                    <h3>Article content by section (editable)</h3>
                    <div class="scrollable-content">
                        {% with standard_sections="title,abstract,introduction,methods,results,discussion,conclusion"|split:"," %}
                            {% for section_key in standard_sections %}
                                <div class="section-editor" id="section-{{ section_key }}">
                                    <h4>
                                        {{ section_key|capfirst }}
                                        <button type="button" class="edit-section-btn" data-section="{{ section_key }}">Edit</button>
                                    </h4>
                                    <div class="section-display" id="display-{{ section_key }}">{{ article.structured_content|json_script:"initial-structured-content-data" }}</div>
                                    <div class="section-form" id="form-{{ section_key }}" style="display:none;">
                                        <textarea id="textarea-{{ section_key }}">
                                            {{ article.structured_content|get_item:section_key|default:"" }}
                                        </textarea>
                                        <div class="actions">
                                            <button type="button" class="save-section-btn" data-section="{{ section_key }}">Save</button>
                                            <button type="button" class="cancel-button cancel-section-btn" data-section="{{ section_key }}">Close</button>
                                        </div>
                                    </div>
                                </div>
                            {% endfor %}
                        {% endwith %}

                        {% if article.structured_content.full_body_fallback and not article.structured_content.introduction %}
                            {# Показываем fallback, если нет основных секций #}
                            <h4>Main text (with no obvious sections):</h4>
                            <div class="section-editor">
                                <p>{{ article.structured_content.full_body_fallback|linebreaksbr }}</p>
                                {# Здесь тоже можно добавить редактирование #}
                            </div>
                        {% endif %}
                    </div>
                </div>
                <div class="tab-content" id="other-sections">
                        

                        {% if article.structured_content.other_sections %}
                            <h3>Other sections:</h3>
                            <div class="scrollable-content">
                            {% for other_sec in article.structured_content.other_sections %}
                                
                                {# Добавляем ID к обертке секции для легкого удаления из DOM #}
                                <div class="section-editor" id="custom-section-{{ forloop.counter0 }}">
                                    <h5>{{ other_sec.title|default:"No title" }}</h5>
                                    <div class="section-display">
                                        {{ other_sec.text|default:"(No text available)"|linebreaksbr }}
                                    </div>
                                    {# TODO: Здесь можно будет добавить и кнопку "Edit" для этих секций позже #}
                                    <div class="actions">
                                        <button type="button" class="delete-custom-section-btn cancel-button"
                                                data-section-index="{{ forloop.counter0 }}"
                                                data-section-title="{{ other_sec.title|default_if_none:''|escapejs }}"
>
                                            Delete this section
                                        </button>
                                    </div>
                                </div>
                            {% endfor %}
                            </div>
                        {% endif %}

                        <button type="button"  id="openAddSectionModalBtn">Add your section</button>
                </div>
                <div class="tab-content" id="structured-content-of-the-article">
                    {% if article.structured_content %}

                            <h3>Structured content of the article</h3>

                            <div class="scrollable-content" style="padding: 20px 20px 0;">

                                {% if article.structured_content.title %}
                                    <h4>{{ article.structured_content.title }}</h4>
                                {% endif %}

                                {% if article.structured_content.abstract %}
                                    <div class="content-section">
                                        <h5>Abstract</h5>
                                        <p>{{ article.structured_content.abstract|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if article.structured_content.introduction %}
                                    <div class="content-section">
                                        <h5>Introduction</h5>
                                        <p>{{ article.structured_content.introduction|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if article.structured_content.methods %}
                                    <div class="content-section">
                                        <h5>Methods</h5>
                                        <p>{{ article.structured_content.methods|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if article.structured_content.results %}
                                    <div class="content-section">
                                        <h5>Results</h5>
                                        <p>{{ article.structured_content.results|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if article.structured_content.discussion %}
                                    <div class="content-section">
                                        <h5>Discussion</h5>
                                        <p>{{ article.structured_content.discussion|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if article.structured_content.other_sections %}
                                    {% for sec in article.structured_content.other_sections %}
                                        <div class="content-section">
                                            <h5>{{ sec.title|default:"Additional section" }}</h5>
                                            <p>{{ sec.text|linebreaksbr }}</p>
                                        </div>
                                    {% endfor %}
                                {% endif %}

                                {% if article.structured_content.conclusion %}
                                    <div class="content-section">
                                        <h5>Conclusion</h5>
                                        <p>{{ article.structured_content.conclusion|linebreaksbr }}</p>
                                    </div>
                                {% endif %}

                                {% if not article.structured_content.introduction and not article.structured_content.methods and article.structured_content.full_body_fallback %}
                                    <div class="content-section">
                                        <h5>Main text (without sections)</h5>
                                        <p>{{ article.structured_content.full_body_fallback|linebreaksbr }}</p>
                                    </div>
                                {% endif %}
                            </div>

                    {% endif %}
                </div>
                <div class="tab-content" id="clear-text-for-llm">
                    {% if article.cleaned_text_for_llm %}

                            <h3>Clear text (for LLM)</h3>
                            <div class="scrollable-content">
                                {{ article.cleaned_text_for_llm|linebreaksbr }}
                            </div>

                    {% endif %}
                </div>
                <div class="tab-content" id="list-of-references">
                    {% if references_made %}

                            <h3>List of references ({{ references_made|length }} references)</h3>
                            <div class="actions">
                                <button onclick="findAllReferenceDois('{{ article.id }}', this)">Find DOIs for all undiscovered</button>
                                <button onclick="loadAllLinkedReferences('{{ article.id }}', this)">Download all from DOI</button>
                                <button type="button" class="add-section-btn stroked-button" onclick="openAddReferenceModal()">Add a link manually</button>
                            </div>

                            <div class="scrollable-content">
                                <ul class="reference-list" style="padding-left:0; list-style:none;">
                                    {% for ref in references_made %}
                                        <li>
                                        <p>
                                            {% if ref.manual_data_json.title %}
                                            Reference #{{ forloop.counter }}: <strong>{{ ref.manual_data_json.title }}</strong><br>
                                            {% endif %}

                                            {% if ref.raw_reference_text %}
                                            {{ ref.raw_reference_text|truncatechars:200 }}<br>
                                            {% endif %}

                                            {% if ref.manual_data_json.year %}
                                            (Year: {{ ref.manual_data_json.year }})
                                            {% endif %}
                                        </p>

                                        <p>
                                            <strong>Target DOI:</strong> {{ ref.target_article_doi|default:"Not found" }} <br>
                                            <strong>PubMed ID:</strong> {{ ref.resolved_article.pubmed_id|default:"Not found" }} <br>
                                            <strong>PubMed Central ID (PMC):</strong> {{ ref.resolved_article.pmc_id|default:"Not found" }} <br>

                                            {% if ref.resolved_article.pdf_file %}
                                            <strong>PDF:</strong>
                                            <a href="{{ ref.resolved_article.pdf_file.url }}" target="_blank"> Open article PDF</a>
                                            {% else %}
                                            <strong>PDF:</strong> No PDF file available
                                            {% endif %}

                                            <br>

                                            {% if ref.resolved_article %}
                                            <strong>Status in DB:</strong> Linked to article
                                            <a href="{% url 'article_detail' ref.resolved_article.pk %}">
                                                "{{ ref.resolved_article.title|truncatechars:50 }}"
                                            </a>
                                            {% else %}
                                            <strong>Status in DB:</strong> Not linked to a local article
                                            {% endif %}
                                        </p>

                                        <span class="status">Reference processing status: {{ ref.get_status_display }}</span>

                                        <div class="actions">
                                            {% if not ref.target_article_doi and ref.status != "doi_lookup_in_progress" %}
                                            <!-- Don't show button if DOI lookup is in progress -->
                                            <button onclick="findDoiForReference({{ ref.id }}, this)">Find DOI</button>
                                            {% elif ref.status == "doi_lookup_in_progress" %}
                                            <button disabled>Searching for DOI...</button>
                                            {% else %}
                                            <button disabled title="DOI already found or provided">Find DOI</button>
                                            {% endif %}

                                            {% if ref.target_article_doi and not ref.resolved_article and ref.status != "article_fetch_in_progress" %}
                                            <button onclick="loadReferencedArticle({{ ref.id }}, this)">Load by DOI</button>
                                            {% elif ref.status == "article_fetch_in_progress" %}
                                            <button disabled>Loading article...</button>
                                            {% else %}
                                            <button disabled title="No DOI or article already loaded/linked">Load by DOI</button>
                                            {% endif %}

                                            <button onclick="openEditModal(
                                            {{ ref.id }},
                                            '{{ ref.raw_reference_text|escapejs }}',
                                            '{{ ref.target_article_doi|default_if_none:""|escapejs }}',
                                            '{{ ref.manual_data_json.title|default_if_none:""|escapejs }}',
                                            '{{ ref.manual_data_json.year|default_if_none:""|escapejs }}',
                                            '{{ ref.status|escapejs }}',
                                            '{{ ref.get_status_display|escapejs }}'
                                            )">Edit</button>

                                            <button onclick="deleteReference({{ ref.id }}, this)" style="background-color: #d9534f; color:white;">Delete</button>
                                        </div>
                                        </li>
                                    {% endfor %}
                                </ul>

                            </div>
                    {% endif %}
                </div>

            </div>

           

            

            

            {% comment %} {% if article.abstract %}
            <div class="detail-section abstract">
                <h3>Annotation</h3>
                <p>{{ article.abstract|linebreaksbr }}</p>
            </div>
            {% endif %} {% endcomment %}

            {% comment %} {% if article.structured_content %}
                <div class="detail-section structured-text">
                    <h3>Structured content of the article</h3>
                    {% if article.structured_content.title %}
                        <h4>{{ article.structured_content.title }}</h4>
                    {% endif %}

                    {% if article.structured_content.abstract %}
                        <div class="content-section">
                            <h5>Abstract</h5>
                            <p>{{ article.structured_content.abstract|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if article.structured_content.introduction %}
                        <div class="content-section">
                            <h5>Introduction</h5>
                            <p>{{ article.structured_content.introduction|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if article.structured_content.methods %}
                        <div class="content-section">
                            <h5>Methods</h5>
                            <p>{{ article.structured_content.methods|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if article.structured_content.results %}
                        <div class="content-section">
                            <h5>Results</h5>
                            <p>{{ article.structured_content.results|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if article.structured_content.discussion %}
                        <div class="content-section">
                            <h5>Discussion</h5>
                            <p>{{ article.structured_content.discussion|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if article.structured_content.other_sections %}
                        {% for sec in article.structured_content.other_sections %}
                            <div class="content-section">
                                <h5>{{ sec.title|default:"Additional section" }}</h5>
                                <p>{{ sec.text|linebreaksbr }}</p>
                            </div>
                        {% endfor %}
                    {% endif %}

                    {% if article.structured_content.conclusion %}
                        <div class="content-section">
                            <h5>Conclusion</h5>
                            <p>{{ article.structured_content.conclusion|linebreaksbr }}</p>
                        </div>
                    {% endif %}

                    {% if not article.structured_content.introduction and not article.structured_content.methods and article.structured_content.full_body_fallback %}
                        <div class="content-section">
                            <h5>Main text (without sections)</h5>
                            <p>{{ article.structured_content.full_body_fallback|linebreaksbr }}</p>
                        </div>
                    {% endif %}
                </div>
            {% endif %} {% endcomment %}


            
        </div>
    </div>
</div>

{# *** МОДАЛЬНОЕ ОКНО ДЛЯ ДОБАВЛЕНИЯ ССЫЛКИ *** #}
<div id="addReferenceModal" style="display:none; position:fixed; flex-direction: column; z-index:1050; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">
        <div style="display: flex; gap: 10px; align-items: center;margin-bottom: 20px;">
            <h3 style="flex:1; margin: 0px;">Add New Reference</h3>
            <button onclick="closeAddReferenceModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>
        <form id="addReferenceForm">
            <p>
                <label for="addRefTargetDoi">Target DOI (if known):</label>
                <input type="text" id="addRefTargetDoi" name="target_article_doi" placeholder="10.xxxx/xxxxx">
            </p>

            <p>
                <label for="addRefTitle">Title of the cited article:</label>
                <input type="text" id="addRefTitle" name="title" placeholder="Title of the cited article">
            </p>

            <p>
                <label for="addRefYear">Year:</label>
                <input type="text" id="addRefYear" name="year" placeholder="YYYY">
            </p>

            <p>
                <label for="addRefRawText">Full reference text (citation):</label>
                <textarea id="addRefRawText" name="raw_reference_text" rows="3" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;"></textarea>
            </p>

            <button type="submit">Save New Reference</button>

            <button type="button" onclick="closeAddReferenceModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>

{# === МОДАЛЬНОЕ ОКНО ДЛЯ СОЗДАНИЯ НОВОГО АНАЛИЗИРУЕМОГО СЕГМЕНТА === #}
<div id="segmentCreationModal" style="display:none; flex-direction: column; position:fixed; z-index:1060; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.5);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:70%; max-width:700px; border-radius:5px;">
        <span onclick="closeSegmentCreationModal()" style="color:#aaa; float:right; font-size:28px; font-weight:bold; cursor:pointer;">&times;</span>
        <h3>Create New Analyzed Segment</h3>

        <form id="segmentCreationForm">
            <p>
                <label for="segmentSectionKey">Section key/title (e.g., introduction, methods, or heading):</label>
                <input type="text" id="segmentSectionKey" name="section_key" placeholder="Section name">
            </p>

            <p>
                <label for="segmentText">Segment text:</label>
                <textarea id="segmentText" name="segment_text" rows="5" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;" required></textarea>
            </p>

            <p>
                <label for="segmentInlineCitations">Inline citation markers (comma-separated, e.g.: [1], (Smith 2023)):</label>
                <input type="text" id="segmentInlineCitations" name="inline_citation_markers" placeholder="[1], [2-5], (Author et al., Year)">
            </p>

            <div style="margin-bottom: 15px;">
                <label>Link to bibliography references:</label>
                <div id="segmentReferencesChecklist" style="max-height: 200px; overflow-y: auto; border: 1px solid #ccc; padding:10px;">
                    <p>Loading reference list...</p>
                </div>
            </div>

            <button type="submit">Save Segment</button>

            <button type="button" onclick="closeSegmentCreationModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>


{# *** МОДАЛЬНОЕ ОКНО ДЛЯ ДОБАВЛЕНИЯ НОВОЙ СЕКЦИИ *** #}
<div id="addSectionModal" style="display:none; position:fixed; flex-direction: column; z-index:1050; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 20px;">
            <h3 style="flex: 1; margin: 0;">Add New Section</h3>
            <button onclick="closeAddSectionModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>

        <form id="addSectionForm">
            <p>
                <label for="newSectionTitle">New Section Title:</label>
                <input type="text" id="newSectionTitle" name="title" required>
            </p>

            <p>
                <label for="newSectionText">New Section Text:</label>
                <textarea id="newSectionText" name="text" rows="5" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;" required></textarea>
            </p>

            <button type="submit">Save Section</button>

            <button type="button" onclick="closeAddSectionModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>


<div id="editReferenceModal" style="display:none; position:fixed; flex-direction: column; z-index:1000; left:0; top:0; width:100%; height:100%; overflow:auto; background-color:rgba(0,0,0,0.4);">
    <div style="background-color:#fefefe; margin:auto; padding:20px; border:1px solid #888; width:60%; max-width:600px; border-radius:5px;">

        <div style="display: flex; gap: 10px; align-items: center;">
            <h3 style="flex:1 ; margin: 0;">Edit Reference</h3>
            <button onclick="closeEditModal()" type="button" class="modal-toggle-button" isnotchangabletext="">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M6.4 19L5 17.6L10.6 12L5 6.4L6.4 5L12 10.6L17.6 5L19 6.4L13.4 12L19 17.6L17.6 19L12 13.4L6.4 19Z" fill="black"></path>
                </svg>
            </button>
        </div>

        <form id="editReferenceForm">
            <input type="hidden" id="editRefId" name="id">

            <p>
                <label for="editRefRawText">Reference Text (Raw):</label>
                <textarea id="editRefRawText" name="raw_reference_text" rows="3" style="width: calc(100% - 22px); padding:10px; border:1px solid #ddd;"></textarea>
            </p>

            <p>
                <label for="editRefTargetDoi">Target DOI:</label>
                <input type="text" id="editRefTargetDoi" name="target_article_doi" placeholder="10.xxxx/xxxxx">
            </p>

            <p>
                <label for="editRefManualTitle">Title (from Manual Data):</label>
                <input type="text" id="editRefManualTitle" name="manual_title" placeholder="Cited article title">
            </p>

            <p>
                <label for="editRefManualYear">Year (from Manual Data):</label>
                <input type="text" id="editRefManualYear" name="manual_year" placeholder="YYYY">
            </p>

            {# Other fields from manual_data_json if needed #}

            <p>
                <label for="editRefStatus">Status (current: <span id="currentRefStatusDisplay"></span>):</label>
                <select id="editRefStatus" name="status">
                    {% for value, display_name in ref_status_choices %}
                        <option value="{{ value }}">{{ display_name }}</option>
                    {% endfor %}
                </select>
            </p>

            <button type="submit">Save Changes</button>

            <button type="button" onclick="closeEditModal()" style="background-color:#ccc;">Cancel</button>
        </form>
    </div>
</div>

{% endblock %}


{% block extra_js %}
<script>
// Получаем данные из тега script, созданного json_script
// Получаем начальное состояние structured_content
const structuredContentElement = document.getElementById('initial-structured-content-data');
let initialArticleStructuredContent = JSON.parse(structuredContentElement.textContent || '{}');

// Получаем данные о ссылках из тега script, созданного json_script
const refsDataElement = document.getElementById('article-references-data-script');
const articleReferencesDataForModal = JSON.parse(refsDataElement.textContent || '[]');
// articleReferencesDataForModal будет массивом массивов: [[pk, doi, raw_text, manual_data_json_object_or_null], ...]

// Получаем данные из тега script, созданного json_script
//const structuredContentElement = document.getElementById('initial-structured-content-data');
//let initialArticleStructuredContent = JSON.parse(structuredContentElement.textContent || '{}');

//const initialArticleStructuredContent = JSON.parse(document.getElementById('initial-structured-content-data').textContent || '{}');
//const articleReferencesData = JSON.parse(document.getElementById('article-references-data').textContent || '[]');

// --- JavaScript для создания анализируемого сегмента ---
const createSegmentBtn = document.getElementById('createSegmentBtn');
const segmentCreationModal = document.getElementById('segmentCreationModal');
const segmentCreationForm = document.getElementById('segmentCreationForm');
const segmentSectionKeyInput = document.getElementById('segmentSectionKey');
const segmentTextInput = document.getElementById('segmentText');
const segmentInlineCitationsInput = document.getElementById('segmentInlineCitations');
const segmentReferencesChecklistDiv = document.getElementById('segmentReferencesChecklist');
const articleIdForSegments = "{{ article.pk }}";

//const initialArticleStructuredContent = JSON.parse(document.getElementById('initial-structured-content-data').textContent || '{}');
const addSectionModal = document.getElementById('addSectionModal');
const addSectionForm = document.getElementById('addSectionForm');
const newSectionTitleInput = document.getElementById('newSectionTitle');
const newSectionTextInput = document.getElementById('newSectionText');

function closeAddSectionModal() {
    if (addSectionModal) addSectionModal.style.display = 'none';
}

// --- JavaScript для модального окна добавления новой ССЫЛКИ ---
const addReferenceModal = document.getElementById('addReferenceModal');
const addReferenceForm = document.getElementById('addReferenceForm');


// Показываем/скрываем кнопку "Создать сегмент" при выделении текста
document.addEventListener('mouseup', function(event) {
    const selection = window.getSelection();
    if (selection.toString().trim().length > 5) { // Показываем кнопку, если выделено больше 5 символов
        // Проверяем, что выделение не внутри модального окна или textarea
        let parent = selection.anchorNode;
        while (parent != null && parent !== document.body) {
            if (parent.id === 'segmentCreationModal' || parent.id === 'editReferenceModal' || parent.id === 'addSectionModal' || parent.tagName === 'TEXTAREA' || parent.tagName === 'INPUT') {
                createSegmentBtn.style.display = 'none';
                return;
            }
            parent = parent.parentNode;
        }
        createSegmentBtn.style.display = 'block';
    } else {
        // Не скрываем кнопку сразу, если клик был не по ней (чтобы можно было нажать)
        if (event.target !== createSegmentBtn && !createSegmentBtn.contains(event.target)) {
                createSegmentBtn.style.display = 'none';
        }
    }
});


if (createSegmentBtn) {
    createSegmentBtn.addEventListener('click', function() {
        const selectedText = window.getSelection().toString().trim();
        if (selectedText) {
            segmentTextInput.value = selectedText;
            // Пытаемся определить секцию, откуда был выделен текст (упрощенно)
            let parentElement = window.getSelection().anchorNode;
            let sectionKeyGuess = '';
            while(parentElement && parentElement !== document.body) {
                if(parentElement.id && parentElement.id.startsWith('section-')) {
                    sectionKeyGuess = parentElement.id.replace('section-', '');
                    break;
                } else if (parentElement.classList && parentElement.classList.contains('section-editor')) {
                    const h4 = parentElement.querySelector('h4 .edit-section-btn');
                    if (h4 && h4.dataset.section) sectionKeyGuess = h4.dataset.section;
                    else { // Для other_sections
                        const h5 = parentElement.querySelector('h5');
                        if(h5) sectionKeyGuess = h5.textContent.trim();
                    }
                    break;
                }
                parentElement = parentElement.parentNode;
            }
            segmentSectionKeyInput.value = sectionKeyGuess;

            populateReferencesChecklist();
            segmentCreationModal.style.display = 'flex';
        }
        this.style.display = 'none'; // Скрываем кнопку после открытия модала
    });
}


function closeSegmentCreationModal() {
    if (segmentCreationModal) segmentCreationModal.style.display = 'none';
}


function populateReferencesChecklist() {
    segmentReferencesChecklistDiv.innerHTML = '';
    if (articleReferencesDataForModal.length === 0) {
        segmentReferencesChecklistDiv.innerHTML = '<p>There are no links for this article.</p>';
        return;
    }
    articleReferencesDataForModal.forEach(ref_data_array => {
        // ref_data_array это [pk, target_article_doi, raw_reference_text, manual_data_json]
        const ref_pk = ref_data_array[0];
        const ref_doi = ref_data_array[1];
        const ref_raw_text = ref_data_array[2];
        const ref_manual_data = ref_data_array[3] || {}; // manual_data_json может быть null

        let refLabelText = `ID: ${ref_pk}`;
        if (ref_doi) {
            refLabelText += ` (DOI: ${ref_doi})`;
        } else if (ref_manual_data && ref_manual_data.title) { // Проверка, что ref_manual_data не null
            refLabelText += ` (${String(ref_manual_data.title).substring(0,50)}...)`;
        } else if (ref_raw_text) {
            refLabelText += ` (${String(ref_raw_text).substring(0,50)}...)`;
        }

        const checkboxId = `ref-check-${ref_pk}`;
        const div = document.createElement('div');
        div.innerHTML = `<input type="checkbox" id="${checkboxId}" name="cited_references" value="${ref_pk}">
                            <label for="${checkboxId}">${refLabelText}</label>`;
        segmentReferencesChecklistDiv.appendChild(div);
    });
}


if (segmentCreationForm) {
    segmentCreationForm.addEventListener('submit', function(event) {
        event.preventDefault();

        const selectedReferenceIds = Array.from(segmentCreationForm.querySelectorAll('input[name="cited_references"]:checked'))
                                        .map(cb => parseInt(cb.value, 10));

        const inlineMarkersText = segmentInlineCitationsInput.value.trim();
        const inlineMarkersArray = inlineMarkersText ? inlineMarkersText.split(',').map(s => s.trim()).filter(s => s) : [];

        const payload = {
            article_id: articleIdForSegments,
            section_key: segmentSectionKeyInput.value.trim() || null,
            segment_text: segmentTextInput.value.trim(),
            inline_citation_markers: inlineMarkersArray,
            cited_references: selectedReferenceIds
        };

        if (!payload.segment_text) {
            alert("Segment text cannot be empty.");
            return;
        }

        const saveButton = segmentCreationForm.querySelector('button[type="submit"]');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';

        addNotificationToDetail({ payload: { status: 'INFO', message: `Saving new segment...`, identifier: `ArticleID:${articleIdForSegments}` } });

        fetch(`/api/articles/analyzed-segments/`, { // Endpoint for creation
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok && (status_code === 201 || status_code === 200)) { // 201 Created
                addNotificationToDetail({ payload: { status: 'SUCCESS', message: `Segment successfully created (ID: ${data.id}).` }});
                closeSegmentCreationModal();
                window.location.reload(); // Easiest way to refresh the segment list
            } else {
                let errorMessage = `Error creating segment (${status_code}): `;
                if (data) {
                    for (const field in data) {
                        errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                    }
                } else {
                    errorMessage += "Unknown server error.";
                }
                addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage, identifier: `ArticleID:${articleIdForSegments}` }});
            }
        })
        .catch(error => {
            console.error('Error creating segment:', error);
            addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}`, identifier: `ArticleID:${articleIdForSegments}` }});
        })
        .finally(() => {
            if(saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = 'Save Segment';
            }
        });
    });
}


function toggleRawContent(element, contentId) {
    const contentDiv = document.getElementById(contentId);
    if (contentDiv.style.display === "none" || contentDiv.style.display === "") {
        contentDiv.style.display = "block";
        element.textContent = "Hide";
    } else {
        contentDiv.style.display = "none";
        element.textContent = "Show";
    }
}


const notificationsDiv = document.getElementById('notifications');
const currentUserIdForWS = "{{ user_id }}"; // Из контекста Django

// --- WebSocket для уведомлений (скопировано и адаптировано из submit_article.html) ---
let ws_protocol_detail = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
let ws_url_detail = `${ws_protocol_detail}//${window.location.host}/ws/notifications/`;
let socket_detail;


function connectWebSocketDetail() {
    if (!currentUserIdForWS || currentUserIdForWS === 'None') return;

    socket_detail = new WebSocket(ws_url_detail);

    socket_detail.onopen = function(e) {
        console.log("WebSocket (detail page) connection established.");
        // You can add a message to notificationsDiv here if needed
    };

    socket_detail.onmessage = function(event) {
        const data = JSON.parse(event.data);
        console.log("WebSocket (detail page) message received:", data);
        // Filter notifications to show only those related to the current article, if possible.
        // For example, if the payload included article_id for filtering.
        // Currently, send_user_notification does not include the source article ID in the payload.
        // For now, all user notifications will be shown.
        addNotificationToDetail(data);
    };

    socket_detail.onclose = function(event) {
        console.error('WebSocket (detail page) connection closed:', event);
        setTimeout(connectWebSocketDetail, 5000); // Attempt reconnection after 5 seconds
    };

    socket_detail.onerror = function(error) {
        console.error('WebSocket (detail page) error:', error);
    };
}


function addNotificationToDetail(data) {
    const notificationsContainer = document.getElementById('notifications'); // Target the inner div
    const initialMsg = notificationsContainer.querySelector('p[style*="text-align: center"]');
    if (initialMsg) {
        initialMsg.remove(); // Remove the initial "Waiting for notifications..." message
    }

    let notificationHtml = `<div class="status-${data.payload?.status || 'INFO'}">`;
    if (data.type === 'connection_established') {
        notificationHtml += `<strong>${data.message || data.payload?.message}</strong>`;
    } else if (data.type === 'task_notification' && data.payload) {
        const p = data.payload;
        notificationHtml += `<strong>Task [${p.task_id || 'N/A'}] from ${p.source_api || 'Source'} (${p.identifier || 'N/A'})</strong><br>`;
        notificationHtml += `Status: ${p.status}<br>`;
        notificationHtml += `Message: ${p.message}<br>`;
        if (p.progress_percent !== undefined) {
            notificationHtml += `Progress: ${p.progress_percent}%<br>`;
        }
        if (p.article_id) {
            notificationHtml += `Article ID: ${p.article_id} (Created: ${p.created === undefined ? 'N/A' : p.created})<br>`;
        }
    } else if (data.payload) {
        notificationHtml += `<strong>${data.payload.source_api || 'System'} (${data.payload.identifier || 'N/A'})</strong><br>`;
        notificationHtml += `Status: ${data.payload.status}<br>`;
        notificationHtml += `Message: ${data.payload.message}<br>`;
        if (data.payload.progress_percent !== undefined) {
            notificationHtml += `Progress: ${data.payload.progress_percent}%<br>`;
        }
    } else {
        notificationHtml += JSON.stringify(data);
    }
    notificationHtml += `</div>`;
    notificationsContainer.insertAdjacentHTML('afterbegin', notificationHtml); // Add new on top
}

connectWebSocketDetail(); // Подключаемся при загрузке страницы


function getCSRFToken() {
    // Ищем токен в фиктивной форме
    const csrfInput = document.querySelector('form[style="display:none;"] input[name="csrfmiddlewaretoken"]');
    if (csrfInput) {
        return csrfInput.value;
    }
    // Запасной вариант: ищем в cookies
    const cookies = document.cookie.split(';');
    for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        if (cookie.startsWith('csrftoken=')) {
            return cookie.substring('csrftoken='.length, cookie.length);
        }
    }
    return ''; // Возвращаем пустую строку, если не найден
}


function loadReferencedArticle(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    // Temporarily disable the button to prevent double clicks
    buttonElement.disabled = true;
    buttonElement.textContent = 'Loading...';

    const apiUrl = `/api/articles/reference-links/${referenceLinkId}/load-article/`;

    addNotificationToDetail({ // Local user notification
        payload: {
            status: 'INFO',
            message: `Sending request to load article for link ID ${referenceLinkId}...`,
            identifier: `RefLinkID:${referenceLinkId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(), // Required for POST requests in Django
            'Content-Type': 'application/json'
        },
        // body: JSON.stringify({}) // Request body not required for this endpoint
    })
    .then(response => {
        // Do not re-enable the button unless the response is not successful,
        // as the status will be updated via WebSocket and the button will disappear/be disabled automatically
        return response.json().then(data => ({ ok: response.ok, status: response.status, data }));
    })
    .then(({ ok, status, data }) => {
        console.log('Response from API load-referenced-article:', data);
        if (ok) { // 200, 201, 202
            if (data.info) { // If the server indicates the article is already linked
                addNotificationToDetail({
                    payload: {
                        status: 'INFO',
                        message: data.info,
                        identifier: `RefLinkID:${referenceLinkId}`
                    }
                });
                buttonElement.textContent = 'Already loaded';
                buttonElement.disabled = true;
            } else {
                addNotificationToDetail({
                    payload: {
                        status: 'SUCCESS',
                        message: data.message || `Load request for link ID ${referenceLinkId} successfully sent.`,
                        identifier: `RefLinkID:${referenceLinkId}`
                    }
                });
                // Keep button disabled, as status will update via WebSocket
                buttonElement.textContent = 'In progress';
            }
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || JSON.stringify(data)}`,
                    identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Load by DOI';
        }
    })
    .catch(error => {
        console.error('Error calling API load-referenced-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error: ${error.message}`,
                identifier: `RefLinkID:${referenceLinkId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Load by DOI';
    });
}


function findDoiForReference(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Searching DOI...';

    const apiUrl = `/api/articles/reference-links/${referenceLinkId}/find-doi/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending request to find DOI for reference link ID ${referenceLinkId}...`,
            identifier: `RefLinkID:${referenceLinkId}` // Use reference link ID as notification identifier
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API find-doi-for-reference:', data);
        if (ok) {
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `DOI search request for reference link ID ${referenceLinkId} sent successfully.`,
                    identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            // Keep the button disabled, as the status will update via WebSocket
            // and the button will either disappear (if DOI is found), or update its text/state.
            buttonElement.textContent = 'Searching...'; // Temporary label
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `RefLinkID:${referenceLinkId}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Find DOI';
        }
    })
    .catch(error => {
        console.error('Error calling API find-doi-for-reference:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error: ${error.message}`,
                identifier: `RefLinkID:${referenceLinkId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Find DOI';
    });
}


function findAllReferenceDois(articleId, buttonElement) {
    if (!articleId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Starting search...';

    const apiUrl = `/api/articles/articles/${articleId}/find-all-reference-dois/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending request to perform bulk DOI lookup for article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API find-all-reference-dois:', data);
        if (ok) { // 200, 202
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Bulk DOI lookup started.`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        // You can leave the button disabled or update text, as WebSocket updates will follow
        buttonElement.textContent = 'Search started';
        // Optional: re-enable button after some time
        // setTimeout(() => {
        //     buttonElement.disabled = false;
        //     buttonElement.textContent = 'Find DOI for all unmatched';
        // }, 5000); // For example, after 5 seconds
    })
    .catch(error => {
        console.error('Error calling API find-all-reference-dois:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Find DOI for all unmatched';
    });
}


const editModal = document.getElementById('editReferenceModal');
const editForm = document.getElementById('editReferenceForm');
const editRefIdInput = document.getElementById('editRefId');
const editRefRawTextInput = document.getElementById('editRefRawText');
const editRefTargetDoiInput = document.getElementById('editRefTargetDoi');
const editRefManualTitleInput = document.getElementById('editRefManualTitle');
const editRefManualYearInput = document.getElementById('editRefManualYear');
const editRefStatusSelect = document.getElementById('editRefStatus');
const currentRefStatusDisplaySpan = document.getElementById('currentRefStatusDisplay');


function openEditModal(refId, rawText, targetDoi, manualTitle, manualYear, currentStatus, currentStatusDisplay) {
    editRefIdInput.value = refId;
    editRefRawTextInput.value = rawText || ''; // Убедимся, что не 'None' или 'undefined'
    editRefTargetDoiInput.value = targetDoi || '';
    editRefManualTitleInput.value = manualTitle || '';
    editRefManualYearInput.value = manualYear || '';
    editRefStatusSelect.value = currentStatus || '';
    currentRefStatusDisplaySpan.textContent = currentStatusDisplay || 'N/A';

    editModal.style.display = 'flex';
}


function closeEditModal() {
    editModal.style.display = 'none';
}


editForm.addEventListener('submit', function(event) {
    event.preventDefault();
    const refId = editRefIdInput.value;

    // Collect data from the form. manual_data_json should be an object
    const manualData = {
        title: editRefManualTitleInput.value.trim() || null,
        year: editRefManualYearInput.value.trim() || null,
        // If manual_data_json can contain other fields, you should load the full object
        // when opening the modal and update only the changed fields here
    };

    // To avoid losing other fields in manual_data_json that aren't editable in this form,
    // it's better to load the full manual_data_json when opening the modal and update it.
    // For simplicity, we recreate it here with only the fields from the form.
    // If manual_data_json is more complex, more advanced logic is needed.

    const payload = {
        raw_reference_text: editRefRawTextInput.value.trim(),
        target_article_doi: editRefTargetDoiInput.value.trim() || null, // Send null if empty
        manual_data_json: manualData,
        status: editRefStatusSelect.value // User can update status, if allowed
    };

    // Remove null values from manualData to keep the JSON clean
    for (const key in payload.manual_data_json) {
        if (payload.manual_data_json[key] === null || payload.manual_data_json[key] === '') {
            delete payload.manual_data_json[key];
        }
    }
    if (Object.keys(payload.manual_data_json).length === 0) {
        payload.manual_data_json = null; // Send null if the object is empty
    }

    const apiUrl = `/api/articles/referencelinks/${refId}/`; // Standard detail endpoint for PATCH/PUT

    addNotificationToDetail({ payload: { status: 'INFO', message: `Saving changes for reference link ID ${refId}...`, identifier: `RefLinkID:${refId}` } });

    fetch(apiUrl, {
        method: 'PATCH', // Use PATCH for partial updates
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        if (ok) {
            addNotificationToDetail({ payload: { status: 'SUCCESS', message: `Reference link ID ${refId} updated successfully.`, identifier: `RefLinkID:${refId}` } });
            closeEditModal();
            // Reload the page to reflect changes — easiest approach.
            // Alternatively, you could update just the relevant entry in the list with JS.
            window.location.reload();
        } else {
            let errorMessage = `Error (${status}): `;
            if (data) {
                for (const field in data) {
                    errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                }
            } else {
                errorMessage += "Unknown server error.";
            }
            addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage, identifier: `RefLinkID:${refId}` } });
        }
    })
    .catch(error => {
        console.error('Error updating ReferenceLink:', error);
        addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network or parsing error: ${error.message}`, identifier: `RefLinkID:${refId}` } });
    });
});


function loadAllLinkedReferences(articleId, buttonElement) {
    if (!articleId) return;

    buttonElement.disabled = true;
    buttonElement.textContent = 'Starting loading...';

    const apiUrl = `/api/articles/articles/${articleId}/load-all-linked-references/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending request to bulk load articles by references for article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API load-all-linked-references:', data);
        if (ok) { // 200, 202
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Bulk loading of articles by references has started.`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || data.info || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        buttonElement.textContent = 'Loading started';
        // You can add logic to re-enable the button after some time
        // setTimeout(() => {
        //     buttonElement.disabled = false;
        //     buttonElement.textContent = 'Load all with DOI';
        // }, 10000); // For example, after 10 seconds
    })
    .catch(error => {
        console.error('Error when calling API load-all-linked-references:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Load all with DOI';
    });
}

function reprocessArticle(articleId, buttonElement) {
    if (!articleId) return;

    if (!confirm("Are you sure you want to reprocess this article? Existing data may be updated.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Reprocessing...';

    const apiUrl = `/api/articles/articles/${articleId}/reprocess/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending request to reprocess article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'POST',
        headers: {
            'X-CSRFToken': getCSRFToken(),
            'Content-Type': 'application/json'
        },
    })
    .then(response => response.json().then(data => ({ ok: response.ok, status: response.status, data })))
    .then(({ ok, status, data }) => {
        console.log('Response from API reprocess-article:', data);
        if (ok) { // 202 Accepted
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Reprocess request for article ID ${articleId} successfully sent.`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Error (${status}): ${data.error || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
        }
        // Keep button disabled or update text, since WebSocket will show progress updates
        buttonElement.textContent = 'Processing';
        // Optionally re-enable button after a timeout:
        // setTimeout(() => { buttonElement.disabled = false; buttonElement.textContent = 'Reprocess Article'; }, 5000);
    })
    .catch(error => {
        console.error('Error calling API reprocess-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Reprocess Article';
    });
}

function deleteArticle(articleId, buttonElement) {
    if (!articleId) return;

    if (!confirm("Are you sure you want to delete this article and all related data? This action cannot be undone.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Deleting...';

    // Standard DRF endpoint to delete the object
    const apiUrl = `/api/articles/articles/${articleId}/`;

    addNotificationToDetail({
        payload: {
            status: 'INFO',
            message: `Sending request to delete article ID ${articleId}...`,
            identifier: `ArticleID:${articleId}`
        }
    });

    fetch(apiUrl, {
        method: 'DELETE', // Using DELETE method
        headers: {
            'X-CSRFToken': getCSRFToken(),
            // 'Content-Type': 'application/json' // DELETE usually does not require Content-Type or body
        },
    })
    .then(response => {
        if (response.status === 204) { // 204 No Content - successful deletion
            return { ok: true, status: response.status, data: { message: "Article successfully deleted." } };
        }
        // If there is an error response body
        return response.json().then(data => ({ ok: response.ok, status: response.status, data }));
    })
    .then(({ ok, status, data }) => {
        console.log('Response from API delete-article:', data);
        if (ok) { // 204 No Content
            addNotificationToDetail({
                payload: {
                    status: 'SUCCESS',
                    message: data.message || `Article ID ${articleId} successfully deleted. Redirecting to article list...`,
                    identifier: `ArticleID:${articleId}`
                }
            });
            // Redirect to article list after successful deletion
            window.location.href = "{% url 'article_list' %}";
        } else {
            addNotificationToDetail({
                payload: {
                    status: 'FAILURE',
                    message: `Delete error (${status}): ${data.error || data.detail || JSON.stringify(data)}`,
                    identifier: `ArticleID:${articleId}`
                }
            });
            buttonElement.disabled = false;
            buttonElement.textContent = 'Delete Article';
        }
    })
    .catch(error => {
        console.error('Error calling API delete-article:', error);
        addNotificationToDetail({
            payload: {
                status: 'FAILURE',
                message: `Network or parsing error during deletion: ${error.message}`,
                identifier: `ArticleID:${articleId}`
            }
        });
        buttonElement.disabled = false;
        buttonElement.textContent = 'Delete Article';
    });
}

document.addEventListener('DOMContentLoaded', function() {
    // ... (существующие слушатели, например, для toggleButtons связанных статей, если это на другой странице) ...

    document.querySelectorAll('.edit-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            const displayDiv = document.getElementById(`display-${sectionKey}`);
            const formDiv = document.getElementById(`form-${sectionKey}`);
            const textarea = document.getElementById(`textarea-${sectionKey}`);

            // Скрываем отображение текста и кнопку "Edit"
            displayDiv.style.display = 'none';
            this.style.display = 'none';

            // Показываем форму редактирования
            formDiv.style.display = 'block';

            // ЗАПОЛНЯЕМ TEXTAREA из initialArticleStructuredContent
            // Это гарантирует, что мы берем текст конкретной секции, как он был загружен с сервера,
            // или пустоту, если для этой секции текста не было.
            textarea.value = initialArticleStructuredContent[sectionKey] || ""; // Если ключа нет или значение null/undefined, будет пустая строка

            textarea.focus();
        });
    });

    document.querySelectorAll('.cancel-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            document.getElementById(`form-${sectionKey}`).style.display = 'none';
            document.getElementById(`display-${sectionKey}`).style.display = 'block';
            document.querySelector(`.edit-section-btn[data-section="${sectionKey}"]`).style.display = 'inline-block';
        });
    });

    // Обработчик для .save-section-btn (использует initialArticleStructuredContent для формирования payload)
    document.querySelectorAll('.save-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionKey = this.dataset.section;
            const newText = document.getElementById(`textarea-${sectionKey}`).value.trim();
            const articleId = "{{ article.pk }}";

            // Создаем глубокую копию initialArticleStructuredContent (или текущего состояния, если вы его обновляете в JS)
            // и обновляем только нужную секцию
            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            if (newText) {
                payloadStructuredContent[sectionKey] = newText;
            } else {
                // Если текст пустой, удаляем ключ из объекта, чтобы на бэкенде секция тоже очистилась или удалилась
                // (зависит от того, как ваш бэкенд обрабатывает отсутствие ключа при PATCH)
                // Если хотите передать пустую строку, то: payloadStructuredContent[sectionKey] = "";
                delete payloadStructuredContent[sectionKey];
            }

            const payload = {
                structured_content: payloadStructuredContent
            };

            button.disabled = true;
            button.textContent = 'Saving...';
            addNotificationToDetail({ payload: { status: 'INFO', message: `Saving section "${sectionKey}"...`, identifier: `ArticleID:${articleId}` } });

            fetch(`/api/articles/articles/${articleId}/`, {
                method: 'PATCH',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({ payload: { status: 'SUCCESS', message: `Section "${sectionKey}" saved successfully.` }});
                    // Вместо обновления DOM вручную, перезагружаем страницу,
                    // чтобы все данные, включая initialArticleStructuredContent и cleaned_text_for_llm, были актуальны.
                    window.location.reload();
                } else {
                    let errorMessage = `Save error (${status_code}): `;
                    if (data) {
                        for (const field in data) {
                            errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                        }
                    } else { errorMessage += "Unknown server error." }
                    addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage, identifier: `ArticleID:${articleId}` }});
                    button.disabled = false; // Возвращаем кнопку в активное состояние при ошибке
                    button.textContent = 'Save';
                }
            })
            .catch(error => {
                console.error(`Error saving section ${sectionKey}:`, error);
                addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}`, identifier: `ArticleID:${articleId}` }});
                button.disabled = false;
                button.textContent = 'Сохранить';
            });
        });
    });

    // Функции теперь могут быть определены внутри DOMContentLoaded или на верхнем уровне,
    // так как они будут вызываться из слушателей, определенных в той же области видимости.
    function openAddSectionModal() {
        if (newSectionTitleInput) newSectionTitleInput.value = '';
        if (newSectionTextInput) newSectionTextInput.value = '';
        if (addSectionModal) addSectionModal.style.display = 'flex';
        if (newSectionTitleInput) newSectionTitleInput.focus();
    }


    // Слушатель для кнопки открытия модального окна
    const openModalButton = document.getElementById('openAddSectionModalBtn');
    if (openModalButton) {
        openModalButton.addEventListener('click', openAddSectionModal);
    }

    if (addSectionForm) { // Проверка на существование формы
        addSectionForm.addEventListener('submit', function(event) {
            event.preventDefault();
            const sectionTitle = newSectionTitleInput.value.trim();
            const sectionText = newSectionTextInput.value.trim();
            const articleId = "{{ article.pk }}";

            if (!sectionTitle || !sectionText) {
                alert("Section title and text cannot be empty.");
                return;
            }

            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            if (!Array.isArray(payloadStructuredContent.other_sections)) {
                payloadStructuredContent.other_sections = [];
            }
            payloadStructuredContent.other_sections.push({
                title: sectionTitle,
                text: sectionText
            });

            const payload = { structured_content: payloadStructuredContent };
            const saveButton = addSectionForm.querySelector('button[type="submit"]');
            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';


            addNotificationToDetail({ payload: { status: 'INFO', message: `Adding section "${sectionTitle}"...`, identifier: `ArticleID:${articleId}` } });

            fetch(`/api/articles/articles/${articleId}/`, {
                method: 'PATCH',
                headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({ payload: { status: 'SUCCESS', message: `Section "${sectionTitle}" added successfully.` }});
                    closeAddSectionModal();
                    // Обновляем initialArticleStructuredContent глобально, если не перезагружаем
                    if (data && data.structured_content) { // Предполагаем, что API возвращает обновленный article или structured_content
                        initialArticleStructuredContent = data.structured_content;
                    }
                    window.location.reload(); // Перезагрузка для простоты
                } else {
                    // ... обработка ошибок ...
                    let errorMessage = `Add section error (${status_code}): `;

                    if (data) { for (const field in data) { errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `; } }
                    else { errorMessage += "Unknown server error." }
                    addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage, identifier: `ArticleID:${articleId}` }});
                }
            })
            .catch(error => {
                // ... обработка ошибок ...
                addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}`, identifier: `ArticleID:${articleId}` }});

            })
            .finally(() => {
                if (saveButton) { // Проверяем, что saveButton все еще существует
                    saveButton.disabled = false;
                    saveButton.textContent = 'Save Section';

                }
            });
        });
    }

    // Слушатели для кнопок удаления кастомных секций
    // Используем делегирование событий, если секции могут добавляться динамически без перезагрузки
    // Но так как у нас пока перезагрузка после добавления/редактирования, прямой поиск кнопок сработает.
    document.querySelectorAll('.delete-custom-section-btn').forEach(button => {
        button.addEventListener('click', function() {
            const sectionIndex = parseInt(this.dataset.sectionIndex, 10);
            const sectionTitle = this.dataset.sectionTitle || "эту секцию";
            const articleId = "{{ article.pk }}";

            if (isNaN(sectionIndex)) {
                console.error("Incorrect section index for deletion.");
                addNotificationToDetail({ payload: { status: 'FAILURE', message: 'Error: Could not determine section to delete.' }});
                return;
            }

            if (!confirm(`Are you sure you want to delete section "${sectionTitle}"? This action is irreversible.`)) {
                return;
            }

            // Создаем глубокую копию initialArticleStructuredContent
            let payloadStructuredContent = JSON.parse(JSON.stringify(initialArticleStructuredContent || {}));

            // Убеждаемся, что other_sections существует и является массивом
            if (payloadStructuredContent.other_sections && Array.isArray(payloadStructuredContent.other_sections)) {
                if (sectionIndex >= 0 && sectionIndex < payloadStructuredContent.other_sections.length) {
                    payloadStructuredContent.other_sections.splice(sectionIndex, 1); // Удаляем элемент по индексу
                } else {
                    console.error(`Section index ${sectionIndex} is out of range for other_sections.`);
                    addNotificationToDetail({ payload: { status: 'FAILURE', message: 'Error: Section for deletion not found (wrong index).' }});
                    return;
                }
            } else {
                console.warn("Array 'other_sections' is not found or is not an array in structured_content.");
                // Если other_sections нет, то и удалять нечего - это странная ситуация, если кнопка была нажата
                addNotificationToDetail({ payload: { status: 'INFO', message: 'No custom sections for deletion.' }});
                return;
            }

            const payload = {
                structured_content: payloadStructuredContent
            };

            this.disabled = true;
            this.textContent = 'Удаление...';

            addNotificationToDetail({
                payload: {
                    status: 'INFO',
                    message: `Deleting a section "${sectionTitle}"...`,
                    identifier: `ArticleID:${articleId}`
                }
            });

            fetch(`/api/articles/articles/${articleId}/`, {
                method: 'PATCH',
                headers: {
                    'X-CSRFToken': getCSRFToken(),
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            })
            .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
            .then(({ok, status_code, data}) => {
                if (ok) {
                    addNotificationToDetail({ payload: { status: 'SUCCESS', message: `Section "${sectionTitle}" has been successfully deleted.` }});
                    // Динамическое удаление HTML элемента секции со страницы
                    const sectionElementToRemove = document.getElementById(`custom-section-${sectionIndex}`);
                    if (sectionElementToRemove) {
                        sectionElementToRemove.remove();
                    }

                    // Обновляем наш локальный initialArticleStructuredContent, чтобы он был актуален
                    // если пользователь захочет удалить еще одну секцию без перезагрузки страницы.
                    if (data && data.structured_content) {
                        initialArticleStructuredContent = data.structured_content;
                    } else {
                        // Если API не вернул обновленный structured_content, берем наш измененный payload
                        initialArticleStructuredContent = payloadStructuredContent;
                    }
                    // Перезагрузка страницы для полной синхронизации (включая cleaned_text_for_llm) - более простой вариант
                    // window.location.reload();
                } else {
                    let errorMessage = `Section deletion error (${status_code}): `;
                    if (data) { for (const field in data) { errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `; } }
                    else { errorMessage += "Неизвестная ошибка сервера." }
                    addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage, identifier: `ArticleID:${articleId}` }});
                    this.disabled = false; // Возвращаем кнопку в активное состояние при ошибке
                    this.textContent = 'Delete this section';
                }
            })
            .catch(error => {
                console.error('Error when deleting a custom section:', error);
                addNotificationToDetail({ payload: { status: 'FAILURE', message: `Сетевая ошибка: ${error.message}`, identifier: `ArticleID:${articleId}` }});
                this.disabled = false;
                this.textContent = 'Delete this section';
            });
        });
    });

});


document.querySelectorAll('.llm-analyze-segment-btn').forEach(button => {
    button.addEventListener('click', function() {
        const segmentId = this.dataset.segmentId;
        if (!segmentId) return;

        const paramKey = 'segmentID';
        const paramValue = segmentId;

        const url = new URL(window.location);
        url.searchParams.set(paramKey, paramValue);

        history.replaceState(null, '', url);

        if (!confirm("Run LLM analysis for this segment? This may take some time.")) {
            return;
        }

        this.disabled = true;
        this.textContent = 'LLM Analyzing...';

        const resultsDiv = document.getElementById(`llm-analysis-results-${segmentId}`);
        if (resultsDiv) {
            resultsDiv.innerHTML = '<p><strong>LLM Analysis:</strong> Request sent, waiting...</p>';
        }

        addNotificationToDetail({ payload: { status: 'INFO', message: `Request for LLM analysis for segment ID ${segmentId}...`, identifier: `SegmentID:${segmentId}` } });

        fetch(`/api/articles/analyzed-segments/${segmentId}/run-llm-analysis/`, {
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok) { // 202 Accepted
                addNotificationToDetail({ payload: { status: 'SUCCESS', message: data.message || `LLM analysis task for segment ID ${segmentId} has been queued.`, identifier: `SegmentID:${segmentId}` }});
                // Button text will be updated via WebSocket or can be changed here to "In progress"
                this.textContent = 'LLM in progress...';
            } else {
                addNotificationToDetail({ payload: { status: 'FAILURE', message: `Error starting LLM analysis (${status_code}): ${data.error || JSON.stringify(data)}`, identifier: `SegmentID:${segmentId}` }});
                this.disabled = false;
                this.textContent = 'Analyse with the LLM';
            }
        })
        .catch(error => {
            console.error('Error starting LLM analysis for segment:', error);
            addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}`, identifier: `SegmentID:${segmentId}` }});
            this.disabled = false;
            this.textContent = 'Analyse with the LLM';
        });
    });
});


function openAddReferenceModal() {
    if(addReferenceForm) addReferenceForm.reset(); // Очищаем форму
    if(addReferenceModal) addReferenceModal.style.display = 'flex';
}


function closeAddReferenceModal() {
    if(addReferenceModal) addReferenceModal.style.display = 'none';
}


if (addReferenceForm) {
    addReferenceForm.addEventListener('submit', function(event) {
        event.preventDefault();
        const articleId = "{{ article.pk }}";
        const formData = new FormData(this);

        const manualData = {
            title: formData.get('title'),
            year: formData.get('year')
        };

        const payload = {
            source_article: articleId, // ID of the current (target) article
            target_article_doi: formData.get('target_article_doi').trim() || null,
            raw_reference_text: formData.get('raw_reference_text').trim(),
            manual_data_json: manualData,
        };

        const saveButton = this.querySelector('button[type="submit"]');
        saveButton.disabled = true;
        saveButton.textContent = 'Saving...';

        fetch(`/api/articles/referencelinks/`, { // POST to list endpoint to create
            method: 'POST',
            headers: { 'X-CSRFToken': getCSRFToken(), 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        })
        .then(response => response.json().then(data => ({ok: response.ok, status_code: response.status, data})))
        .then(({ok, status_code, data}) => {
            if (ok && status_code === 201) { // 201 Created
                addNotificationToDetail({ payload: { status: 'SUCCESS', message: `New reference successfully added (ID: ${data.id}).` }});
                closeAddReferenceModal();
                window.location.reload(); // Reload page to see the new reference in the list
            } else {
                let errorMessage = `Error adding reference (${status_code}): `;
                if (data) {
                    for (const field in data) {
                        errorMessage += `${field}: ${Array.isArray(data[field]) ? data[field].join(', ') : data[field]} `;
                    }
                } else {
                    errorMessage += "Unknown server error.";
                }
                addNotificationToDetail({ payload: { status: 'FAILURE', message: errorMessage }});
            }
        })
        .catch(error => {
            console.error('Error adding new reference:', error);
            addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}` }});
        })
        .finally(() => {
            if(saveButton) {
                saveButton.disabled = false;
                saveButton.textContent = 'Save new reference';
            }
        });
    });
}


function deleteReference(referenceLinkId, buttonElement) {
    if (!referenceLinkId) return;

    if (!confirm("Are you sure you want to delete this reference? This action is irreversible.")) {
        return;
    }

    buttonElement.disabled = true;
    buttonElement.textContent = 'Deleting...';

    const apiUrl = `/api/articles/referencelinks/${referenceLinkId}/`;

    fetch(apiUrl, {
        method: 'DELETE',
        headers: {
            'X-CSRFToken': getCSRFToken(),
        },
    })
    .then(response => {
        if (response.status === 204) { // 204 No Content - successful deletion
            return { ok: true, data: { message: "Reference successfully deleted." } };
        }
        // If response has an error body
        return response.json().then(data => ({ ok: false, status_code: response.status, data }));
    })
    .then(({ ok, status_code, data }) => {
        if (ok) {
            addNotificationToDetail({ payload: { status: 'SUCCESS', message: data.message }});

            // Dynamically remove the reference HTML element from the page
            const liElementToRemove = buttonElement.closest('li'); // Find the parent <li>
            if (liElementToRemove) {
                liElementToRemove.remove();
            }
            // Reloading the page is a simpler option if dynamic update is problematic
            // window.location.reload();
        } else {
            addNotificationToDetail({ payload: { status: 'FAILURE', message: `Error deleting (${status_code}): ${data.detail || JSON.stringify(data)}` }});
            buttonElement.disabled = false;
            buttonElement.textContent = 'Delete';
        }
    })
    .catch(error => {
        console.error('Error deleting reference:', error);
        addNotificationToDetail({ payload: { status: 'FAILURE', message: `Network error: ${error.message}` }});
        buttonElement.disabled = false;
        buttonElement.textContent = 'Delete';
    });
}

// Закрытие модального окна при клике вне его (опционально)
window.onclick = function(event) {
    if (event.target == editModal) {
        closeEditModal();
    }
}

// закрытие модального окна при клике вне его
window.addEventListener('click', function(event) {
    if (addReferenceModal && event.target == addReferenceModal) {
        closeAddReferenceModal();
    }

    // Закрытие модального окна создания сегмента при клике вне его
    if (segmentCreationModal && event.target == segmentCreationModal) {
        closeSegmentCreationModal();
    }

    if (addSectionModal && event.target == addSectionModal) {
        closeAddSectionModal();
    }
    // ... (обработка для других модальных окон, если нужно) ...
});


</script>
{% endblock %}