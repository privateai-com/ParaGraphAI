# Generated by Django 5.2.4 on 2025-07-19 20:10

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='Author',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('full_name', models.CharField(max_length=255, verbose_name='Full Name')),
                ('first_name', models.CharField(blank=True, max_length=50, verbose_name='First Name')),
                ('middle_name', models.CharField(blank=True, max_length=50, verbose_name='Middle Name')),
                ('last_name', models.CharField(blank=True, max_length=50, verbose_name='Last Name')),
                ('orcid', models.CharField(blank=True, db_index=True, help_text='ORCID: Open Researcher and Contributor ID (Ex.: Stephen Hawking — https://orcid.org/0000-0002-9079-593X)', max_length=255, null=True, unique=True, verbose_name='ORCID')),
                ('affiliation', models.JSONField(blank=True, null=True, verbose_name='Affiliation')),
                ('created', models.DateTimeField(auto_now_add=True, verbose_name='Created')),
                ('updated', models.DateTimeField(auto_now=True, verbose_name='Updated')),
                ('order', models.PositiveIntegerField(default=0, verbose_name='Order')),
            ],
            options={
                'verbose_name': 'Author',
                'verbose_name_plural': 'Authors',
                'ordering': ['order'],
            },
        ),
        migrations.CreateModel(
            name='Article',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('title', models.TextField(verbose_name='Title of the article')),
                ('abstract', models.TextField(blank=True, null=True, verbose_name='Annotation')),
                ('doi', models.CharField(blank=True, db_index=True, max_length=255, null=True, unique=True, verbose_name='DOI')),
                ('pubmed_id', models.CharField(blank=True, db_index=True, max_length=50, null=True, unique=True, verbose_name='PubMed ID')),
                ('pmc_id', models.CharField(blank=True, db_index=True, max_length=50, null=True, unique=True, verbose_name='PubMed Central (PMC) ID')),
                ('arxiv_id', models.CharField(blank=True, max_length=50, null=True, verbose_name='arXiv ID')),
                ('cleaned_text_for_llm', models.TextField(blank=True, help_text='Full text of the article, cleaned and prepared for LLM analysis. Can be added manually.', null=True, verbose_name='Cleared text for the LLM')),
                ('is_manually_added_full_text', models.BooleanField(default=False, help_text='Indicates whether the full text of the article was added manually by the user.', verbose_name='Full text added manually')),
                ('pdf_file', models.FileField(blank=True, max_length=500, null=True, upload_to='articles_pdf/', verbose_name='PDF файл')),
                ('pdf_text', models.TextField(blank=True, help_text='Text content of a pdf file obtained from MarkItDown, MarkerPDF or others.', null=True, verbose_name='Text from PDF')),
                ('pdf_url', models.URLField(blank=True, help_text='PDF download link', max_length=2048, null=True, verbose_name='URL PDF')),
                ('primary_source_api', models.CharField(blank=True, help_text='API from which the basic metadata for this record was taken (title, abstract).', max_length=100, null=True, verbose_name='Primary source API')),
                ('publication_date', models.DateField(blank=True, null=True, verbose_name='Publication date')),
                ('journal_name', models.CharField(blank=True, max_length=512, null=True, verbose_name='Name of journal/source')),
                ('oa_status', models.CharField(blank=True, help_text='Open Access status from Unpaywall (e.g., gold, green, bronze, closed)', max_length=50, null=True, verbose_name='Open Access status')),
                ('best_oa_url', models.URLField(blank=True, help_text='Link to the best OA version (HTML/landing) from Unpaywall', max_length=2048, null=True, verbose_name='URL of the best OA version')),
                ('best_oa_pdf_url', models.URLField(blank=True, help_text='Link to PDF of the best OA version from Unpaywall', max_length=2048, null=True, verbose_name='URL PDF of the best OA version')),
                ('oa_license', models.CharField(blank=True, help_text='OA version licence from Unpaywall (e.g., cc-by, cc-by-nc)', max_length=100, null=True, verbose_name='OA version licence')),
                ('is_user_initiated', models.BooleanField(db_index=True, default=False, help_text='True if this article was added by the user directly and not as a linked article.', verbose_name='Добавлено пользователем напрямую')),
                ('structured_content', models.JSONField(blank=True, default=dict, help_text='Content of the article, organised into sections (например, abstract, introduction, methods, results, discussion, conclusion)', null=True, verbose_name='Структурированное содержимое')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Date of update')),
                ('user', models.ForeignKey(help_text='User who added an article to the system', on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL, verbose_name='User')),
            ],
            options={
                'verbose_name': 'Research paper',
                'verbose_name_plural': 'Scientific articles',
                'ordering': ['-updated_at', '-created_at'],
            },
        ),
        migrations.CreateModel(
            name='ArticleAuthor',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('sequence', models.CharField(blank=True, help_text='Ex.: "first", "additional"', max_length=50, verbose_name='Sequence')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Date of update')),
                ('article', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='article.article')),
                ('author', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='article.author')),
            ],
            options={
                'verbose_name': 'Author of the article',
                'verbose_name_plural': 'Authors of the articles',
                'unique_together': {('article', 'author')},
            },
        ),
        migrations.AddField(
            model_name='article',
            name='authors',
            field=models.ManyToManyField(blank=True, related_name='articles', through='article.ArticleAuthor', to='article.author', verbose_name='Авторы'),
        ),
        migrations.CreateModel(
            name='ReferenceLink',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('raw_reference_text', models.TextField(blank=True, help_text='Link text as it appears in the original article.', null=True, verbose_name='Source link text')),
                ('target_article_doi', models.CharField(blank=True, db_index=True, help_text='DOI of the referenced article. Can be entered/edited by the user.', max_length=255, null=True, verbose_name='DOI of the cited article')),
                ('manual_data_json', models.JSONField(blank=True, help_text='JSON with metadata of the cited article, if it is added manually (title, authors, year, etc.).', null=True, verbose_name='Данные, введенные вручную')),
                ('status', models.CharField(choices=[('pending_doi_input', 'Waiting for DOI entry/retrieval'), ('doi_lookup_in_progress', 'A DOI for the reference is being searched'), ('doi_provided_needs_lookup', 'DOI found, awaiting article download'), ('article_fetch_in_progress', 'DOI article download in progress'), ('article_linked', 'Article found and linked'), ('article_not_found', 'Article not found by DOI'), ('manual_entry', 'Data entered manually'), ('manual_metadata_only', 'Metadata entered manually (unlinked)'), ('error_doi_lookup', 'Error in DOI search'), ('error_article_fetch', 'Error when loading an article'), ('error_processing', 'Processing error')], default='pending_doi_input', max_length=50, verbose_name='Link Status')),
                ('log_messages', models.TextField(blank=True, help_text='Messages about the search process, downloads, errors.', null=True, verbose_name='Processing logs')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Date of update')),
                ('order', models.PositiveIntegerField(default=0)),
                ('resolved_article', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='cited_by_references', to='article.article', verbose_name='Linked article in the database')),
                ('source_article', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='references_made', to='article.article', verbose_name='Source Article')),
            ],
            options={
                'verbose_name': 'Bibliographic reference',
                'verbose_name_plural': 'Bibliographic references',
                'ordering': ['order'],
            },
        ),
        migrations.CreateModel(
            name='AnalyzedSegment',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('section_key', models.CharField(blank=True, help_text='For example, introduction, methods, or custom section header.', max_length=255, null=True, verbose_name='Key/section header')),
                ('segment_text', models.TextField(help_text='User-selected or automatically extracted text fragment.', verbose_name='Segment text')),
                ('inline_citation_markers', models.JSONField(blank=True, default=list, help_text="A list of citation text markers found in the segment, e.g., [''[1]'', ''(Smith 2023)''']", null=True, verbose_name='Inline Quotation Markers')),
                ('llm_analysis_notes', models.TextField(blank=True, null=True, verbose_name='LLM Analysis Notes')),
                ('llm_veracity_score', models.FloatField(blank=True, null=True, verbose_name='Assessing the validity of the LLM')),
                ('llm_model_name', models.CharField(blank=True, help_text="For example: 'gpt-4o-mini'", max_length=100, null=True, verbose_name='Name of LLM model')),
                ('prompt_used', models.TextField(blank=True, null=True, verbose_name='Prompt used')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='Creation date')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='Date of update')),
                ('user', models.ForeignKey(blank=True, null=True, on_delete=django.db.models.deletion.SET_NULL, to=settings.AUTH_USER_MODEL, verbose_name='User who created/changed the segment')),
                ('article', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='analyzed_segments', to='article.article', verbose_name='Target item')),
                ('cited_references', models.ManyToManyField(blank=True, related_name='supporting_segments', to='article.referencelink', verbose_name='Quoted/linked references')),
            ],
            options={
                'verbose_name': 'Text segment to be analysed',
                'verbose_name_plural': 'Text segments analysed',
                'ordering': ['article', 'created_at'],
            },
        ),
        migrations.CreateModel(
            name='ArticleContent',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('source_api_name', models.CharField(help_text="For example, 'pubmed', 'crossref_api', 'arxiv_api'", max_length=100, verbose_name='Source API name')),
                ('format_type', models.CharField(help_text="For example, 'json_metadata', 'full_text_xml_pmc', 'xml_fulltext_jats', 'abstract_text', 'references_list_json'", max_length=50, verbose_name='Format type')),
                ('content', models.TextField(verbose_name='Contents')),
                ('retrieved_at', models.DateTimeField(auto_now_add=True, verbose_name='Date and time of download')),
                ('article', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='contents', to='article.article', verbose_name='Article')),
            ],
            options={
                'verbose_name': 'Content of the article from the source',
                'verbose_name_plural': 'Content of articles from sources',
                'unique_together': {('article', 'source_api_name', 'format_type')},
            },
        ),
    ]
